<html>
	<head>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="https://rawgit.com/mrdoob/three.js/dev/build/three.js"> </script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>
		
		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
			
			var container;
			var camera, scene, labelScene, renderer;
			var plane, cube;
			var mouse, raycaster, isShiftDown = false;
			var label;
			
			var rollOverMesh, rollOverMaterial;
			var cubeGeo, cubeMaterial;

			var objects = [];

			init();
			render();
			
			function init() {
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				// camera
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( new THREE.Vector3() );

				// scene
				scene = new THREE.Scene();
				labelScene = new THREE.Scene();
				
				// controls
				controls = new THREE.OrbitControls( camera, container );
				controls.maxPolarAngle = Math.PI;
				controls.minDistance = 1000;
				controls.maxDistance = 7500;
				
				// roll-over helpers
				rollOverGeo = new THREE.BoxGeometry( 50, 50, 50 );
				rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
				rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
				scene.add( rollOverMesh );
				
				// label helper 
				label = makeTextLabel( "kuk", 
							{ fontsize: 100, borderColor: {r:0, g:0, b:255, a:1.0}, backgroundColor: {r:100, g:100, b:255, a:0.8} } );
				label.name = 'label_object_name';
				
				// cubes
				cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xDF1F1F } );

				// grid
				var size = 500, step = 50;
				createGrid3d(scene, size, step);
					
				// labels
				var labelNamesX = ["aaaX","bbbX","cccX","dddX","eeeX","fffX"];
				var labelNamesY = ["aaaY","bbbY","cccY","dddY","eeeY","fffY"];
				var labelNamesZ = ["aaaZ","bbbZ","cccZ","dddZ","eeeZ","fffZ"];
				var labelsX = labelAxis(size, labelNamesX,"x");
				labelsX.position.x = size - 40;
				labelsX.position.y = - 40;
				labelsX.position.z = size + 40 ;
				scene.add(labelsX);
				
				var labelsY = labelAxis(size, labelNamesY,"y");
				labelsY.position.x = -size - 40;
				labelsY.position.y = 40;
				labelsY.position.z = size;
				scene.add(labelsY);
				
				var labelsZ = labelAxis(size, labelNamesZ,"z");
				labelsZ.position.x = size + 40;
				labelsZ.position.y = - 40;
				labelsZ.position.z = size - 40;
				scene.add(labelsZ);

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
				geometry.rotateX( - Math.PI / 2 );

				plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
				scene.add( plane );

				objects.push( plane );

				// Lights
				var ambientLight = new THREE.AmbientLight( 0x404040 );
				scene.add( ambientLight );

				var directionalLight = new THREE.DirectionalLight( 0xffffff );
				directionalLight.position.x = 1;
				directionalLight.position.y = 1;
				directionalLight.position.z = 0.75;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				var directionalLight = new THREE.DirectionalLight( 0x808080 );
				directionalLight.position.x = - 1;
				directionalLight.position.y = 1;
				directionalLight.position.z = - 0.75;
				directionalLight.position.normalize();
				scene.add( directionalLight );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'keydown', onDocumentKeyDown, false );
				document.addEventListener( 'keyup', onDocumentKeyUp, false );
				
				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}
			
			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {
					
					var intersect = intersects[ 0 ];
					if (intersect.object.geometry.type == "BoxGeometry") {
						if (labelScene.getObjectByName('label_object_name') != null) {
							label.position.copy(intersect.object.position);
							label.position.y += 80;
							//label.position.divideScalar( 50 ).floor().multiplyScalar( 50 );
						} else {
							label.position.set(intersect.object.position);
							label.position.y += 80;
							labelScene.add(label);
						}
						console.log(label);
						console.log(intersect.object.position);
					} else {
						labelScene.remove(label);
					}
					

					rollOverMesh.position.copy( intersect.point ).add( intersect.face.normal );
					rollOverMesh.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

				} else {
					labelScene.remove(label);
				}

				render();

			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					var intersect = intersects[ 0 ];

					// delete cube

					if ( isShiftDown ) {

						if ( intersect.object != plane ) {

							scene.remove( intersect.object );

							objects.splice( objects.indexOf( intersect.object ), 1 );

						}

					// create cube

					} else {

						var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						scene.add( voxel );

						objects.push( voxel );

					}

					render();

				}

			}

			function onDocumentKeyDown( event ) {

				switch( event.keyCode ) {

					case 16: isShiftDown = true; break;

				}

			}

			function onDocumentKeyUp( event ) {

				switch ( event.keyCode ) {

					case 16: isShiftDown = false; break;

				}

			}
			
			function createGrid3d(scene, size, step) {
				var geometry = new THREE.Geometry();

				for ( var i = - size; i <= size; i += step ) {
					// spodok
					geometry.vertices.push( new THREE.Vector3( - size, 0, i ) );
					geometry.vertices.push( new THREE.Vector3(   size, 0, i ) );

					geometry.vertices.push( new THREE.Vector3( i, 0, - size ) );
					geometry.vertices.push( new THREE.Vector3( i, 0,   size ) );
					
					// zadna stena
					geometry.vertices.push( new THREE.Vector3( i , - size + 10*step, - 10*step) );
					geometry.vertices.push( new THREE.Vector3( i ,   size + 10*step, - 10*step) );
					
					geometry.vertices.push( new THREE.Vector3( - size, i + 10*step, - 10*step) );
					geometry.vertices.push( new THREE.Vector3(   size, i + 10*step, - 10*step) );
					
					// lava stena 
					geometry.vertices.push( new THREE.Vector3( - 10*step , - size + 10*step, i) );
					geometry.vertices.push( new THREE.Vector3( - 10*step ,   size + 10*step, i) );
					
					geometry.vertices.push( new THREE.Vector3( - 10*step, i + 10*step, - size) );
					geometry.vertices.push( new THREE.Vector3( - 10*step, i + 10*step,   size) );
				}

				var material = new THREE.LineBasicMaterial( { color: 0x000000, opacity: 0.2, transparent: true } );

				var grid = new THREE.LineSegments( geometry, material );
				scene.add( grid );
			}
			
			function makeTextSprite(message, opts) {
				var parameters = opts || {};
				var fontface = parameters.fontface || 'Helvetica';
				var fontsize = parameters.fontsize || 70;
				var canvas = document.createElement('canvas');
				var context = canvas.getContext('2d');
				context.font = fontsize + "px " + fontface;

				// get size data (height depends only on font size)
				var metrics = context.measureText(message);
				var textWidth = metrics.width;

				// text color
				context.fillStyle = 'rgba(0, 0, 0, 1.0)';
				context.fillText(message, 0, fontsize);

				// canvas contents will be used for a texture
				var texture = new THREE.Texture(canvas)
				texture.minFilter = THREE.LinearFilter;
				texture.needsUpdate = true;

				var spriteMaterial = new THREE.SpriteMaterial({
				map: texture
				});
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(100, 50, 1.0);
				return sprite;
			}
			
			function makeTextLabel( message, parameters )
			{
				if ( parameters === undefined ) parameters = {};
				
				var fontface = parameters.hasOwnProperty("fontface") ? 
					parameters["fontface"] : "Arial";
				
				var fontsize = parameters.hasOwnProperty("fontsize") ? 
					parameters["fontsize"] : 18;
				
				var borderThickness = parameters.hasOwnProperty("borderThickness") ? 
					parameters["borderThickness"] : 4;
				
				var borderColor = parameters.hasOwnProperty("borderColor") ?
					parameters["borderColor"] : { r:0, g:0, b:0, a:1.0 };
				
				var backgroundColor = parameters.hasOwnProperty("backgroundColor") ?
					parameters["backgroundColor"] : { r:255, g:255, b:255, a:1.0 };
					
				var canvas = document.createElement('canvas');
				var context = canvas.getContext('2d');
				context.font = "Bold " + fontsize + "px " + fontface;
				
				// get size data (height depends only on font size)
				var metrics = context.measureText( message );
				var textWidth = metrics.width;
				
				// background color
				context.fillStyle   = "rgba(" + backgroundColor.r + "," + backgroundColor.g + ","
											  + backgroundColor.b + "," + backgroundColor.a + ")";
				// border color
				context.strokeStyle = "rgba(" + borderColor.r + "," + borderColor.g + ","
											  + borderColor.b + "," + borderColor.a + ")";

				context.lineWidth = borderThickness;
				roundRect(context, borderThickness/2, borderThickness/2, textWidth + borderThickness, fontsize * 1.4 + borderThickness, 6);
				// 1.4 is extra height factor for text below baseline: g,j,p,q.
				
				// text color
				context.fillStyle = "rgba(0, 0, 0, 1.0)";

				context.fillText( message, borderThickness, fontsize + borderThickness);
				
				// canvas contents will be used for a texture
				var texture = new THREE.Texture(canvas) 
				texture.needsUpdate = true;

				var spriteMaterial = new THREE.SpriteMaterial( 
					{ map: texture } );
				var sprite = new THREE.Sprite( spriteMaterial );
				sprite.scale.set(100,50,1.0);
				return sprite;	
			}
			
			// function for drawing rounded rectangles
			function roundRect(ctx, x, y, w, h, r) 
			{
				ctx.beginPath();
				ctx.moveTo(x+r, y);
				ctx.lineTo(x+w-r, y);
				ctx.quadraticCurveTo(x+w, y, x+w, y+r);
				ctx.lineTo(x+w, y+h-r);
				ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
				ctx.lineTo(x+r, y+h);
				ctx.quadraticCurveTo(x, y+h, x, y+h-r);
				ctx.lineTo(x, y+r);
				ctx.quadraticCurveTo(x, y, x+r, y);
				ctx.closePath();
				ctx.fill();
				ctx.stroke();   
			}
			
			function labelAxis(width, data, direction){

				var separator = 2*width/data.length,
							p = {
								x:0,
								y:0,
								z:0
							},
							dobj = new THREE.Object3D();

				for ( var i = 0; i < data.length; i ++ ) {
						var label = makeTextSprite(data[i]);

						label.position.set(p.x,p.y,p.z);

						dobj.add( label );
						if (direction=="y"){
							p[direction]+=separator;
						}else{
							p[direction]-=separator;
						}

				}
				return dobj;
			}

			function render() {
				renderer.clear();
				renderer.render( scene, camera );
				renderer.clearDepth();
				renderer.render( labelScene, camera );
			}


		</script>
	</body>
</html>